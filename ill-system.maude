***(
  Focused system for Intuitionistic Linear Logic 
  author: Carlos Olarte
  file: ill-system.maude
  
  Sequents may have the following shape
  (1) unfocus: [ Gamma ] Delta |~ G
  The equational theory defined in the module ILL-EQ applies all the
  connectives belonging to the negative phase (in any order)
  Initial goals must use sequents of this shape (in order to guarantee
    that the derivations starts with a negative phase)
  ------------------------------------------------------------------
  (2) Focus on the right [ Gamma ] Delta ==> G
  G is decomposed until a negative formula is found and the sequent is
  reduced to a sequent of the shape (4) below
  ------------------------------------------------------------------
  (3) Focus on the left [ Gamma ] Delta < F > <== G
  G is decomposed until a positive formula is found and the sequent is
  reduced to a sequent of the shape (4) below
  ------------------------------------------------------------------
  (4) End of the positive phase [Gamma ] Delta |- G
  Sequents of this shape signals the end of the positive phase
  ------------------------------------------------------------------
  (5) proved(R, Gamma, Delta, G)
  Proved sequent with the rule R

  A configuration takes the form { L } where L is a list of unproved
  sequents . Initial goals take the form prove(S) where S is a sequent
  or prove(F) where F is a formula

  Definition of the rules (positive phase) are in the module
  ILL-RL. Definitions for the negative phase are in the functional
  module ILL-EQ

  Module PROOF-TREE offers facilities to build a proof tree using the
  meta-level and then, it generates LaTeX code

  For printing(generating latex code), the initial goal is solve(S)
  where S is a sequent (of the shape |~)
  ***)
    
load syntax .

--------------
--- Sequents
--------------
fmod ILL-SEQUENT is 
    sort Sequent .
    pr  MSET-FORMULA .

    --- Negative phase Sequent
    op [_]_|-_ : SFormula MSFormula Formula  -> Sequent [prec 60] .
    --- Sequent needing the negative phase
    op [_]_|~_ : SFormula MSFormula Formula  -> Sequent [prec 60] .
    --- Focused on the right
    op [_]_ ==> _ : SFormula MSFormula Formula  -> Sequent [prec 60] .
    --- Focused on the right
    op [_]_ <_> <== _  : SFormula MSFormula Formula Formula  -> Sequent [prec 60] .
    --- Proved sequent
    op proved : Qid SFormula MSFormula Formula  -> Sequent [ctor] .
    --- Error for the meta-level
    op error : -> Sequent [ctor] .
    
    --- List of sequents
    sort LSequent .
    subsort Sequent < LSequent .
    --- Empty list os sequents
    op none : -> LSequent .
    --- Building lists of sequents
    op _|_ : LSequent LSequent -> LSequent [ctor assoc id: none prec 70] .
    
    --- Configurations
    sort Conf .
    op {_} : LSequent -> Conf [ctor] .
    --- All the goals were proved
    op proved : -> Conf [ctor] .
    --- Error for the meta-level
    op error : -> Conf [ctor] .
    --- Returns the first sequent in a non-empty configuration
    op first : Conf -> Sequent .
    eq first({ Sq:Sequent | L:LSequent}) = Sq:Sequent .
    eq first( { none} ) = error .
    --- Returns the list of sequents of a configuration
    op lseq : Conf -> LSequent .
    eq lseq( {L:LSequent} ) = L:LSequent .

    --- Initial goal
    op prove : Sequent -> Conf .
    --- We assume that Sq is a sequent of the shape |~ 
    eq prove(Sq:Sequent) = { Sq:Sequent } .
    op prove : Formula -> Conf .
    eq prove(F:Formula) = { ([emp] empMS |~ F:Formula) } .
    --- Proving assuming some axioms
    op proveAx : SFormula Formula -> Conf .
    eq proveAx(LF:SFormula, F:Formula) = { [LF:SFormula] empMS |~ F:Formula } .
    

    --- to Latex
    var S : SFormula .
    var L : MSFormula .
    vars F G : Formula .
    var R : Qid .
    var Sq : Sequent .
    var LSq : LSequent .

    op toTex : Sequent -> String .
    op toTexL : LSequent -> String .
    eq toTex(error) = "failed" .
    eq toTex([S] L |~ F) = "\\LLSec{" + toTexS(S) + "}{" + toTexMS(L) + "}{" + toTex(F) + "}" .
    eq toTex([S] L |- F) = "\\LLSec{" + toTexS(S) + "}{" + toTexMS(L) + "}{" + toTex(F) + "}" .
    eq toTex([S] L ==> F) = "\\LLSecR{" + toTexS(S) + "}{" + toTexMS(L) + "}{" + toTex(F) + "}" .
    eq toTex([S] L < F > <== G) = "\\LLSecL{" + toTexS(S) + "}{" + toTexMS(L) + "}{" + toTex(F) + "}{" + toTex(G) + "}" .
    eq toTex(proved(R, S, L, F)) = "\\infer[" + string(R) + "]{" + "\\LLSec{" + toTexS(S) + "}{" + toTexMS(L) + "}{" + toTex(F) + "}" + "}{}" .
    eq toTexL(none) = " " .
    eq toTexL(Sq | LSq ) = toTex(Sq) + ( if  LSq == none then " " else " & " + toTexL(LSq) fi ) .
    
endfm

-----------------------------------------
--- Equations defining the negative phase
-----------------------------------------
fmod ILL-EQ is
    pr ILL-SEQUENT .

    vars CC CC' : SFormula . --- classical contexts
    vars CL CL' : MSFormula . --- linear contexts
    vars F F' G G' : Formula .
    vars A A' : Atom .
    vars L L1 L2 : LSequent .
    var Sq : Sequent .
    --- Rules of the negative phase
    eq [CC] CL , 1 |~ G =
	[CC] CL |~ G . --- ONEL
    eq [CC] CL, 0 |~ G =
	proved('\Rzero , CC, (CL, 0) , G) . --- ZERO
    eq [CC] CL |~ top =
	proved('\Rtop,  CC ,  CL , top)  . --- TOP
    eq [CC] CL |~ G -o G' =
	[CC] CL, G |~ G' . --- implR
    eq [CC] CL, F * F' |~ G =
	[CC] CL, F , F' |~ G . --- tensorL
    eq [CC] CL |~ G & G' =
	([CC] CL |~ G)  | ([CC] CL |~ G') . --- withR
    eq [CC] CL, F o F' |~ G =
	([CC] CL, F |~ G) | ([CC] CL, F' |~ G) . --- plusL
    eq [CC] CL, ! F |~ G =
	[CC ; F] CL |~ G . --- bangL

	--- some simplifications (due to LL equivalence)
    eq [CC ; F & F'] CL |~ G =  [CC ; F ; F'] CL |~ G . --- !(F& F') == !F * ! F'
    eq [CC ; 0] CL |~ G =  proved('\Rzero , (CC ; 0), CL , G) . --- ZERO
endfm
-------------------------------------
--- Rules defining the positive phase
-------------------------------------
mod ILL-RL is
    pr ILL-SEQUENT .
    vars CC CC' : SFormula . *** classical contexts
    vars CL CL' : MSFormula . *** linear contexts
    vars F F' G G' : Formula .
    vars A A' : Atom .
    vars L L'  : LSequent .
    vars S S' T T' Sq : Sequent .

    ----------------------------------------
    --- Auxiliar function handling the meta-level operations
    ----------------------------------------
    --- Transforming a list of |~ sequents into a list of |- sequents
    op readySeq : LSequent -> LSequent .
    op readySeq$ : Sequent -> Sequent .
    eq readySeq(none) = none .
    eq readySeq(Sq | L) = readySeq$(Sq) | readySeq(L) .
    eq readySeq$(([CC] CL |~ F)) = ([CC] CL |- F) .
    eq readySeq$(Sq) = Sq [owise] .
    

    --- Handling the negative phase (via metaReduce in the equational module)
    op negPhase : Sequent -> LSequent .
    eq negPhase(S) = readySeq(downTerm(getTerm(metaReduce( upModule('ILL-EQ, false), upTerm(S))), error)) .

    --- Test if a sequent is provable by applying init
    op isInit : Sequent -> Bool .
    eq isInit( [CC] A ==> A) = true .
    eq isInit([CC ; A] empMS ==> A ) = true .
    eq isInit(Sq) = false [owise] .

    
    --- Negative phase
    rl [Rneg] : { ([CC] CL |~ G) | L } => { negPhase([CC] CL |~ G) | L } .
    --- discarding proved sequents
    rl [prP] : { proved(Q:Qid, CC,  CL ,G) | L } => { L } .
    --- ending the proof
    rl [endP] : { none } => proved .
    --- One
    rl [Rone] : { ([CC] empMS ==> 1) | L } => { proved('\Rone , CC , empMS, 1) | L } .
    --- Init
    rl [Rinit] : { ([CC] A ==> A) | L } => { proved ('\Rinit , CC, A , A)| L } .
    rl [RinitC] : { ([CC ; A] empMS ==> A) | L } => { proved ('\RinitC , (CC ; A) , empMS , A) | L } .
    --- BOT
    rl [Rbot] : { ([CC] empMS < bot > <== bot) | L } => { proved ('\Rbot , CC, bot , bot)| L } .
    --- Tensor
    rl [Rtensor] : { ([CC] CL, CL' ==> G * G') | L } => { ([CC] CL ==> G) | ([CC] CL' ==> G') | L } .
    --- Oplus
    rl [RplusA] : { ([CC] CL ==> G o G') | L } => { ([CC] CL ==> G ) | L } .
    rl [RplusB] : { ([CC] CL ==> G o G') | L } => { ([CC] CL ==> G' ) | L } .
    --- Implication left
    rl [Rimp] : { ([CC] CL, CL' < F -o F' > <== G) | L } => { ([CC] CL ==> F) | ([CC] CL' < F' > <== G) | L } .
    --- With L
    rl [RwithA] : { ([CC] CL < F & F' > <== G) | L } => { ([CC] CL < F > <== G) | L } .
    rl [RwithB] : { ([CC] CL < F & F' > <== G) | L } => { ([CC] CL < F' > <== G) | L } .
    --- BangL
    rl [Rbang] : { ([CC] empMS ==> ! G) | L } => { ([CC] empMS |~ G) | L } .
    --- Deciding
    crl [RdecideL] : { ([CC] CL, F |- G) | L } => { ( [CC] CL < F > <== G) | L } if not isAtom(F) .
    crl [RdecideC] : { ([CC ; F] CL |- G) | L } => { ( [CC ; F] CL < F > <== G) | L } if not isAtom(F) and-then not isInit ([CC ; F] CL |- G) .
    rl [RdecideR] : { ([CC] CL |- G) | L } => { ([CC] CL ==> G) | L } .
    --- Release
    crl [RreleaseL] : { ([CC] CL < F > <== G) | L } => { ( [CC] CL, F |~ G) | L } if releaseL(F) .
    crl [RreleaseR] : { ([CC] CL ==> G) | L } => { ( [CC] CL |~ G) | L } if releaseR(G) .
endm

--- Proof Trees
mod  PROOF-TREE is
    pr ILL-RL .
    --- Trees and list of trees
    sorts Tree LTree .
    subsort String Sequent < Tree < LTree .
    --- Empty tree
    op niltree : -> LTree [ctor] .
    --- Error tree (meta-level)
    op errtree : -> Tree [ctor] .
    --- Concatenating lists of trees
    op _,_ : LTree LTree -> LTree [ctor assoc id: niltree] .
    --- Tree constructor
    op t : Qid String LTree -> Tree .

    --- From list of sequents to lists of trees
    op toTreeList : LSequent -> LTree .
    eq toTreeList(none) = niltree .
    eq toTreeList(Sq:Sequent | LS:LSequent) = Sq:Sequent , toTreeList(LS:LSequent) .

    -----------------------------------
    var Sq : Sequent .
    vars LSq L1 L1' L2 L2' : LSequent .
    vars TS TS' : TraceStep .
    vars Tr Tr' : Trace? .
    vars T T' : Term .
    vars Ty Ty' :  Type .
    vars R R' : Rule .
    vars t t' : Tree .
    vars Q Q' : Qid .
    var Str : String .
    -----------------------------------

    --- Simplify  repeated occurrences of the same sequent in the tree
    op simplify : Tree -> Tree .
    op simplifyL : LTree -> Tree .
    eq simplify(errtree) = errtree .
    eq simplify(t(Q, Str, t(Q', Str, LT:LTree))) = t(Q', Str, simplifyL(LT:LTree)) .
    eq simplify(t(Q, Str,LT:LTree)) = t(Q, Str, simplifyL(LT:LTree)) [owise] .
    eq simplifyL(niltree) = niltree .
    eq simplifyL( (t, LT:LTree) ) = simplify(t), simplifyL(LT:LTree) .

    --- Return the difference between 2 lists of sequents (assuming that tail are the same )
    op tailDiference1 : LSequent LSequent -> LSequent .
    op tailDiference2 : LSequent LSequent -> LSequent .
    eq tailDiference1( (L1 | L1') , (L2 | L1')) = L1 .
    eq tailDiference2( (L1 | L1') , (L2 | L1')) = L2 .

    --- Generating a trace (lists of terms explored in a search procedure) from a sequent
    op toTrace : Sequent -> Trace .
    eq toTrace(Sq) = metaSearchPath(upModule('ILL-RL, false), upTerm(prove(Sq)), 'proved.Conf , nil , '*, unbounded , 0 ) .

    --- Obtaining the first element of the sequent 
    op getFirst : Trace -> Tree .
    eq getFirst( ({ T , Ty, R } Tr) ) = (first(downTerm(T, (error).Conf))) .

    --- Generating trees
    --- Sq expected to be of the form |~
    op toTree : Sequent -> Tree .
    ceq toTree(Sq:Sequent) = (if (Tr == (failure).Trace?) then errtree else toTree(Tr, getFirst(Tr)) fi)
      if Tr := toTrace(Sq:Sequent) .
    op toTree : Trace Tree -> Tree .
    eq toTree(nil, t) = errtree .
    eq toTree( { T , Ty, R }, t ) = t . --- Last transition is only to move from { none} to proved
    ceq toTree( ({ T , Ty, R } { T' , Ty', R' } Tr) , t) = toTree( ({ T' , Ty', R' } Tr) , update(t, L1, L2, ruleName(R))) 
      if L1 := tailDiference1(lseq(downTerm(T , error)) , lseq(downTerm(T' , error))) /\
	  L2 := tailDiference2(lseq(downTerm(T , error)) , lseq(downTerm(T' , error))) .

      
      --- Updating the derivation tree (Last parameter is the rule's name)
    op update : Tree LSequent LSequent Qid -> Tree .
    eq update(t , Sq, LSq, Q:Qid) =
	downTerm(getTerm(metaRewrite(
	      newModule(upTerm(Sq),upTerm(t( (qid("\\" + string(Q:Qid))) , toTex(Sq) , toTreeList(LSq)))),
	      upTerm(t) , 1 )), errtree) .

    --- Generates a (meta)module to simplify the process of
    --- transforming trees. Basically, the module has a unique rewrite
    --- rule that updates one of the nodes (a sequent) into a tree
    --- (with the latex code of the sequent and with the needed
    --- children)
    op newModule : Term Term -> Module .
    eq newModule(T:Term, T':Term) = (mod 'SUBST-TREE is including 'BOOL . protecting 'PROOF-TREE . sorts none . none none none none rl T:Term => T':Term [none] . endm) .

    --- Return the name of a rule
    op ruleName : Rule -> Qid .
    eq ruleName(( ( rl T:Term => T':Term [ label(r:Qid) AS:AttrSet ]. ) R:RuleSet )) = r:Qid .
    eq ruleName(( (crl  T:Term => T':Term if C:Condition [ label(r:Qid) AS:AttrSet ]. ) R:RuleSet )) = r:Qid .

      --- From trees to String
    op printTree : Tree -> String .
    op printTreeL : LTree -> String .
    eq printTree(errtree) = "fail" .
    eq printTree(t(Q, Str, LT:LTree)) = if (Q == '\prP) then "" else "\\infer[" + string(Q) + "]{" + Str + "}{" + printTreeL(LT:LTree) + "}" fi .
    eq printTreeL(niltree) = "" .
    eq printTreeL( t , LT:LTree) = printTree(t) + if (LT:LTree =/= niltree) then " & " + printTreeL(LT:LTree)  else " " fi .

    --- Initial Goal
    op solve : Sequent -> String .
    eq solve(Sq:Sequent) =  printTree(simplify(toTree(Sq:Sequent))) .

    op proveIt : Sequent -> String .
    eq proveIt(Sq:Sequent) = "$" + solve(Sq:Sequent) + "$"  .
endm


--- Some tests
--- search [1] prove([emp] 1 , ! 'p * ! 'q |~ ! ('p * 'q)) =>* proved .
--- search [1] prove([emp] ! 'p * ! 'q |~ ( 'p * 'q) & (( 'q * 'p)  & ('q * 'q ))) =>* proved .
--- search [1] prove((!((!(((!(p) -o p) & (!(p) -o p))) -o 0)) -o 0)) =>* proved .
--- red solve([emp] 1 , ! 'p * ! 'q |~ ! ('p * 'q)) .
---- red solve([emp] ! 'p * ! 'q |~ ( 'p * 'q) & (( 'q * 'p)  & ('q * 'q ))) .


    
    