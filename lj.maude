***(
  LJ System
  author: Carlos Olarte
  file: ill-system.maude
  *)  
    

--- ===================
--- SYNTAX
--- ===================
fmod FORMULA is
    pr META-LEVEL * (op _;_ to op_;;_ , op _,_ to op_C_ ) .
    sort Formula .

    --- Atoms
    sort Atom .
    subsort Qid < Atom < Formula .

    --- Some atoms
    ops a b c p q s : -> Atom .
    eq a = 'a . eq b = 'b . eq c = 'c .
    eq p = 'p . eq q = 'q . eq s = 's .

    --- units
    op 1 : -> Formula [ctor] .
    op 0 : -> Formula [ctor] .

    --- Connectives
    op _&_ : Formula Formula -> Formula [ctor prec 30] . *** with
    op _o_ : Formula Formula -> Formula [ctor prec 30] . *** oplus
    op _-->_ : Formula Formula -> Formula [prec 35] . *** implication for ILL
    op _<-->_ : Formula Formula -> Formula [prec 35] . *** BIimplication for ILL
    op ~_ : Formula -> Formula  . *** negation (just an equation)
    eq ~ F:Formula = F:Formula --> 0 .
    eq F:Formula <--> G:Formula = (F:Formula --> G:Formula) & (G:Formula --> F:Formula) .

    --- Error (for meta-level)
    op errF : -> Formula [ctor] .
    
    ---------------------
    vars F F' G : Formula .
    var A : Atom .
    ---------------------
    
    --- To Latex
    op toTex : Formula -> String .
    eq toTex(Q:Qid) = string(Q:Qid) .
    eq toTex(1) = "\\LJTrue" .
    eq toTex(0) = "\\LJFalse" .
    eq toTex(F & G) = toTex(F) + " \\LJand " + toTex(G) .
    eq toTex(F o G) = toTex(F) + " \\LJor " + toTex(G) .
    eq toTex(F --> G) = toTex(F) + " \\LJimp " + toTex(G) .
endfm

--- ===================
--- SETS OF FORMULAS
--- ===================

fmod SET-FORMULA  is
    pr FORMULA .

    --- Sets
    sort SFormula .
    subsort Formula  < SFormula .
    
    --- Empty set/mset
    op emp : -> SFormula .

    --- Sets are build with ;
    op _;_ : SFormula SFormula -> SFormula [ctor assoc comm id: emp] .
    eq F:Formula ; F:Formula = F:Formula . *** idempotency

    --- to Latex
    op toTexS : SFormula -> String .
    eq toTexS(emp) = " \\LLempty " .
    eq toTexS(F:Formula ; S:SFormula) = toTex(F:Formula) +
	( if S:SFormula == emp then " " else " , " + toTexS(S:SFormula) fi ) .
endfm

--------------
--- Sequents
--------------
fmod LJ-SEQUENT is 
    sort Sequent .
    pr  SET-FORMULA .

    --- Sequents
    op _|-_ : SFormula Formula  -> Sequent [prec 60] .
    op _|~_ : SFormula Formula  -> Sequent [prec 60] .
    op _|~i~_ : SFormula Formula  -> Sequent [prec 60] . --- intial sequent
    --- Proved sequent
    op proved : Qid SFormula Formula  -> Sequent [ctor] .
    --- Error for the meta-level
    op error : -> Sequent [ctor] .
    
    --- Set of sequents
    sort LSequent .
    subsort Sequent < LSequent .
    --- Empty list os sequents
    op none : -> LSequent .
    --- Building lists of sequents
    op _|_ : LSequent LSequent -> LSequent [ctor assoc id: none prec 70] .
    eq S:Sequent | S:Sequent = S:Sequent . *** idempotency
    eq proved(Q:Qid, SF:SFormula, F:Formula) = none . *** already proved sequents
    --- Configurations
    sort Conf .
    op {_} : LSequent -> Conf [ctor] .
    --- All the goals were proved
    op proved : -> Conf [ctor] .
    --- Error for the meta-level
    op error : -> Conf [ctor] .
    --- Returns the first sequent in a non-empty configuration
    op first : Conf -> Sequent .
    eq first({ Sq:Sequent | L:LSequent}) = Sq:Sequent .
    eq first( { none} ) = error .
    --- Returns the list of sequents of a configuration
    op lseq : Conf -> LSequent .
    eq lseq( {L:LSequent} ) = L:LSequent .

    --- Initial goal
    op prove : LSequent -> Conf .
    op $prove : Sequent -> Conf .
    --- We assume that Sq is a sequent of the shape |~i~
    --- eq prove(none) = { none } .
    eq prove(L:LSequent) = { L:LSequent } .
    eq $prove(Sq:Sequent) = { Sq:Sequent } .
    op prove : Formula -> Conf .
    eq prove(F:Formula) = { (emp |~i~ F:Formula) } .
    --- Proving assuming some axioms
    op proveAx : SFormula Formula -> Conf .
    eq proveAx(LF:SFormula, F:Formula) = { LF:SFormula |~i~ F:Formula } .

    --- to Latex
    var S : SFormula .
    vars F G : Formula .
    var R : Qid .
    var Sq : Sequent .
    var LSq : LSequent .

    op toTex : Sequent -> String .
    op toTexL : LSequent -> String .
    eq toTex(error) = "failed" .
    eq toTex(S |~ F) = "\\LJSec{" + toTexS(S) + "}{" + toTex(F) + "}" .
    eq toTex(S |~i~ F) = "\\LJSec{" + toTexS(S) + "}{" + toTex(F) + "}" .
    eq toTex(S |- F) = "\\LJSec{" + toTexS(S) + "}{" + toTex(F) + "}" .
    eq toTex(proved(R, S, F)) = "\\infer[" + string(R) + "]{" + "\\LJSec{" + toTexS(S) + "}{" + toTex(F) + "}" + "}{}" .
    eq toTexL(none) = " " .
    eq toTexL(Sq | LSq ) = toTex(Sq) + ( if  LSq == none then " " else " & " + toTexL(LSq) fi ) .
    
endfm

-----------------------------------------
--- Equations defining the negative phase
-----------------------------------------
fmod LJ-EQ is
    pr LJ-SEQUENT .

    vars CC CC' : SFormula . --- classical contexts
    vars F F' G G' : Formula .
    vars A A' : Atom .
    vars L L1 L2 : LSequent .
    var Sq : Sequent .
    --- Rules of the negative phase
    eq CC ; A |~ A = proved('\Rinit, (CC ; A) , A) .
    eq CC ; 1 |~ G =
	CC |~ G . --- ONEL
    eq CC ; 0 |~ G =
	proved('\Rzero , (CC ; 0) , G) . --- ZERO
    eq CC |~ 1 =
	proved('\Rtop,  CC  , 1)  . --- ONE
    eq  CC |~ G --> G' =
	CC ; G |~ G' . --- implR
    eq CC ; F & F' |~ G =
	CC ; F ; F' |~ G . --- conj Left
    eq CC |~ G & G' =
	( CC |~ G)  | (CC |~ G') . --- conj Right
    eq CC ; F o F' |~ G =
	(CC ; F |~ G) | (CC ;  F' |~ G) . --- disj left

endfm
-------------------------------------
--- Rules defining the positive phase
-------------------------------------
mod LJ-RL is
    --- pr LJ-SEQUENT .
    pr LJ-EQ .
    vars CC CC' : SFormula . *** classical contexts
    vars F F' G G' : Formula .
    vars A A' : Atom .
    vars L L'  : LSequent .
    vars S S' T T' Sq : Sequent .

    ----------------------------------------
    --- Auxiliar function handling the meta-level operations
    ----------------------------------------
    --- Transforming a list of |~ sequents into a list of |- sequents
    op readySeq : LSequent -> LSequent .
    op readySeq$ : Sequent -> Sequent .
    eq readySeq(none) = none .
    eq readySeq(Sq | L) = readySeq$(Sq) | readySeq(L) .
    eq readySeq$(CC |~ F) = (CC |- F) .
    eq readySeq$(Sq) = Sq [owise] .

    --- Test if a sequent is provable by applying init
    op isInit : Sequent -> Bool .
    eq isInit( (A ; CC |- A)) = true .
    eq isInit( (A ; CC |~ A)) = true .
    eq isInit(Sq) = false [owise] .
    

    --- Handling the negative phase (via metaReduce in the equational module)
    op negPhase : SFormula Formula -> LSequent .
    eq negPhase(CC, G) = readySeq(downTerm(getTerm(metaReduce( upModule('LJ-EQ, false), upTerm(CC |~ G))), error)) .
    
    --- Negative phase
    rl [Rneg] : { (CC |~i~ G) | L } =>  { negPhase(CC, G) | L } .
    --- ending the proof
    rl [endP] : { none } => proved .
    --- Implication left
    rl [Limp] : { (CC ; F --> F' |- G) | L } => { (CC ; F --> F' |~i~ F) | (CC ; F' |~i~ G) | L } .
      --- Disj right
    rl [DA] : { (CC |- G o G') | L } => { (CC |~i~ G) | L } .
    rl [DB] : { (CC |- G o G') | L } => { (CC |~i~ G') | L } .
endm

--- Proof Trees
mod  PROOF-TREE is
    pr LJ-RL .
    --- Trees and list of trees
    sorts Tree LTree .
    subsort String Sequent < Tree < LTree .
    --- Empty tree
    op niltree : -> LTree [ctor] .
    --- Error tree (meta-level)
    op errtree : -> Tree [ctor] .
    --- Concatenating lists of trees
    op _,_ : LTree LTree -> LTree [ctor assoc id: niltree] .
    --- Tree constructor
    op t : Qid String LTree -> Tree .

    --- From list of sequents to lists of trees
    op toTreeList : LSequent -> LTree .
    eq toTreeList(none) = niltree .
    eq toTreeList(Sq:Sequent | LS:LSequent) = Sq:Sequent , toTreeList(LS:LSequent) .

    -----------------------------------
    var Sq : Sequent .
    vars LSq L1 L1' L2 L2' : LSequent .
    vars TS TS' : TraceStep .
    vars Tr Tr' : Trace? .
    vars T T' : Term .
    vars Ty Ty' :  Type .
    vars R R' : Rule .
    vars t t' : Tree .
    vars Q Q' : Qid .
    var Str : String .
    -----------------------------------

    --- Simplify  repeated occurrences of the same sequent in the tree
    op simplify : Tree -> Tree .
    op simplifyL : LTree -> Tree .
    eq simplify(errtree) = errtree .
    eq simplify(t(Q, Str, t(Q', Str, LT:LTree))) = t(Q', Str, simplifyL(LT:LTree)) .
    eq simplify(t(Q, Str,LT:LTree)) = t(Q, Str, simplifyL(LT:LTree)) [owise] .
    eq simplifyL(niltree) = niltree .
    eq simplifyL( (t, LT:LTree) ) = simplify(t), simplifyL(LT:LTree) .
    
    --- Return the difference between 2 lists of sequents (assuming that tail are the same )
    op tailDiference1 : LSequent LSequent -> LSequent .
    op tailDiference2 : LSequent LSequent -> LSequent .
    eq tailDiference1( (L1 | L1') , (L2 | L1')) = L1 .
    eq tailDiference2( (L1 | L1') , (L2 | L1')) = L2 .

    --- Generating a trace (lists of terms explored in a search procedure) from a sequent
    op toTrace : Sequent -> Trace .
    eq toTrace(Sq) = metaSearchPath(upModule('LJ-RL, false), upTerm(prove(Sq)), 'proved.Conf , nil , '*, unbounded , 0 ) .

    --- Obtaining the first element of the sequent
    op getFirst : Trace -> Tree .
    eq getFirst( ({ T , Ty, R } Tr) ) = (first(downTerm(T, (error).Conf))) .

    --- Generating trees
    --- Sq expected to be of the form |~
    op toTree : Sequent -> Tree .
    ceq toTree(Sq:Sequent) = (if (Tr == (failure).Trace?) then errtree else toTree(Tr, getFirst(Tr)) fi)
      if Tr := toTrace(Sq:Sequent) .
    op toTree : Trace Tree -> Tree .
    eq toTree(nil, t) = errtree .
    eq toTree( { T , Ty, R }, t ) = t . --- Last transition is only to move from { none} to proved
    ceq toTree( ({ T , Ty, R } { T' , Ty', R' } Tr) , t) = toTree( ({ T' , Ty', R' } Tr) , update(t, L1, L2, ruleName(R)))
      if  L1 := tailDiference1(lseq(downTerm(T , error)) , lseq(downTerm(T' , error))) /\
          L2 := tailDiference2(lseq(downTerm(T , error)) , lseq(downTerm(T' , error))) .
      

      --- Updating the derivation tree (Last parameter is the rule's name)
    op update : Tree LSequent LSequent Qid -> Tree .
    eq update(t , Sq, LSq, Q:Qid) =
        downTerm(getTerm(metaRewrite(
              newModule(upTerm(Sq),upTerm(t( (qid("\\" + string(Q:Qid))) , toTex(Sq) , toTreeList(LSq)))),
              upTerm(t) , 1 )), errtree) .

    --- Generates a (meta)module to simplify the process of
    --- transforming trees. Basically, the module has a unique rewrite
    --- rule that updates one of the nodes (a sequent) into a tree
    --- (with the latex code of the sequent and with the needed
    --- children)
    op newModule : Term Term -> Module .
    eq newModule(T:Term, T':Term) = (mod 'SUBST-TREE is including 'BOOL . protecting 'PROOF-TREE . sorts none . none none none none rl T:Term => T':Term [none] . endm) .

    --- Return the name of a rule
    op ruleName : Rule -> Qid .
    eq ruleName(( ( rl T:Term => T':Term [ label(r:Qid) AS:AttrSet ]. ) R:RuleSet )) = r:Qid .
    eq ruleName(( (crl  T:Term => T':Term if C:Condition [ label(r:Qid) AS:AttrSet ]. ) R:RuleSet )) = r:Qid .

      --- From trees to String
    op printTree : Tree -> String .
    op printTreeL : LTree -> String .
    eq printTree(errtree) = "fail" .
    eq printTree(t(Q, Str, LT:LTree)) = if (Q == '\prP) then "" else "\\infer[" + string(Q) + "]{" + Str + "}{" + printTreeL(LT:LTree) + "}" fi .
    eq printTreeL(niltree) = "" .
    eq printTreeL( t , LT:LTree) = printTree(t) + if (LT:LTree =/= niltree) then " & " + printTreeL(LT:LTree)  else " " fi .

    --- Initial Goal
    op solve : Sequent -> String .
    eq solve(Sq:Sequent) = printTree(simplify(toTree(Sq:Sequent))) .
endm

    
eof
select  LJ-RL .
search [1] { emp |~i~ (~ p --> q) --> ~ ~ (p o q) } =>* proved .
search [1] { 'A --> ('B --> 'C) ; ('A --> 0) --> 0 ; ('B --> 0) --> 0 |~i~ ('C --> 0) --> 0 } =>* proved .
search [1] { emp |~i~ 'A <--> 'A } =>* proved .
rew solve('A --> ('B --> 'C) ; ('A --> 0) --> 0 ; ('B --> 0) --> 0 |~i~ ('C --> 0) --> 0) .


t('\Rneg , "\\LJSec{A \\LJimp B \\LJimp C }{B \\LJimp A \\LJimp C}",
t('\Rneg, "\\LJSec{A , B , A \\LJimp B \\LJimp C }{C}", t('\Limp, "\\LJSec{A , B , A \\LJimp B \\LJimp C }{C}", t('\Rneg, "\\LJSec{A , B , B \\LJimp C }{C}", t('\Limp, "\\LJSec{A , B , B \\LJimp C }{C}", niltree)))))

"\\LJSec{A , B , A \\LJimp B \\LJimp C }{C}"
"\\LJSec{A , B , A \\LJimp B \\LJimp C }{C}"